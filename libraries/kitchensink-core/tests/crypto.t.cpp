#include "gtest/gtest.h"

#include "types/arrayoutstream.h"
#include "types/datarefinstream.h"
#include "types/dataref.h"
#include "types/strref.h"
#include "crypto/cryptoinstream.h"
#include "crypto/cryptooutstream.h"
#include "crypto/entropypool.h"

#include <ostream>

static void PrintTo(const DataRef& dataRef,
             std::ostream*  os)
{
    *os << "Size=" << dataRef.size() << " ";
    
    for (auto d : dataRef)
    {
        *os << (int)d << " ";
    }
}

namespace
{
// D(key, E(key, data)) = data
void sanityCheck(const DataRef& testData,
                 const StrRef&  password,
                 int            prngSeed)
{
    // rand() is a PRNG so don't even think about doing this in real code!
    srand(prngSeed);
    
    Crypto::IV iv;
    Crypto::IV dataIv;
    Crypto::Key dataKey;

    for (auto& x : iv)
    {
        x = uint8_t(rand() & 0xff);
    }

    for (auto& x : dataIv)
    {
        x = uint8_t(rand() & 0xff);
    }
        
    for (auto& x : dataKey)
    {
        x = uint8_t(rand() & 0xff);
    }

    std::array<uint8_t, 1024 * 1024> encryptedData;
    ArrayOutStream encryptedOut(encryptedData);

    {
        CryptoOutStream cryptOut(encryptedOut, password, iv, dataIv, dataKey);

        cryptOut.write(testData);
    }

    ASSERT_GT(encryptedOut.position(), testData.size());

    DataRefInStream encryptedIn(encryptedOut.data());
    
    CryptoInStream cryptIn(encryptedIn, password);
    
    std::array<uint8_t, 1024 * 1024> decryptedData;
    ArrayOutStream decryptedOut(decryptedData);

    std::size_t size(0);
    
    while (true)
    {
        auto read(cryptIn.read(decryptedOut, decryptedOut.remaining()));

        if (read == 0)
        {
            break;
        }
        
        size += read;
    }

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kValidated);
    
    ASSERT_EQ(testData.size(), size);
    ASSERT_EQ(decryptedOut.data(), testData);
}

}

TEST(Crypto, Sanity0)
{
    const uint8_t TestDataRaw[] =
    {
        0, 1, 2, 3
    };
    
    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    StrRef password("test");
    
    sanityCheck(testData, password, 0);
}

TEST(Crypto, Sanity1)
{
    const uint8_t TestDataRaw[] =
    {
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15
    };
    
    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    StrRef password("password!123");
    
    sanityCheck(testData, password, 123);
}

TEST(Crypto, Sanity2)
{
    const uint8_t TestDataRaw[] =
    {
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x00,0x00,0x00,
        0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x00,0x20,0x50,0x50,0x20,0x48,0x20,0x20,0x10,0x40,0x00,
        0x00,0x00,0x00,0x00,0x08,0x70,0x20,0x70,0x70,0x08,0xf8,0x70,0xf8,0x70,0x70,0x00,0x00,0x00,0x00,0x00,
        0x70,0x70,0x70,0xf0,0x70,0xe0,0xf8,0xf8,0x70,0x88,0x70,0x38,0x88,0x80,0x88,0x88,0x70,0xf0,0x70,0xf0,
        0x70,0xf8,0x88,0x88,0x88,0x88,0x88,0xf8,0x70,0x40,0x70,0x50,0x00,0x00,0x00,0x80,0x00,0x08,0x00,0x18,
        0x00,0x80,0x20,0x08,0x40,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
        0x18,0x20,0x60,0xa8,0x0c,0x20,0x50,0x50,0x70,0xa8,0x50,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x08,
        0x88,0x60,0x88,0x88,0x18,0x80,0x80,0x08,0x88,0x88,0x00,0x00,0x08,0x00,0x40,0x88,0x88,0x88,0x88,0x88,
        0x90,0x80,0x80,0x88,0x88,0x20,0x10,0x90,0x80,0xd8,0x88,0x88,0x88,0x88,0x88,0x88,0x20,0x88,0x88,0x88,
        0x88,0x88,0x08,0x40,0x40,0x10,0x88,0x00,0x00,0x00,0x80,0x00,0x08,0x00,0x20,0x00,0x80,0x00,0x00,0x40,
        0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x10,0x90,0x0c,
        0x20,0x00,0xf8,0xa8,0x50,0x50,0x00,0x40,0x10,0x50,0x20,0x00,0x00,0x00,0x10,0x98,0x20,0x88,0x08,0x28,
        0x80,0x80,0x08,0x88,0x88,0x20,0x20,0x10,0xf8,0x20,0x88,0x98,0x88,0x88,0x80,0x88,0x80,0x80,0x80,0x88,
        0x20,0x10,0xa0,0x80,0xa8,0xc8,0x88,0x88,0x88,0x88,0x80,0x20,0x88,0x88,0x88,0x50,0x50,0x10,0x40,0x20,
        0x10,0x00,0x00,0x00,0x70,0xf0,0x70,0x78,0x70,0x70,0x78,0xf0,0x60,0x18,0x48,0x20,0xf0,0xf0,0x70,0xf0,
        0x78,0xb8,0x78,0x70,0x88,0x88,0x88,0x88,0x88,0xf8,0x20,0x20,0x10,0x00,0x18,0x20,0x00,0x50,0xa0,0x10,
        0x20,0x00,0x40,0x10,0x20,0x20,0x00,0x00,0x00,0x10,0xa8,0x20,0x08,0x30,0x48,0xf0,0xf0,0x10,0x70,0x88,
        0x20,0x20,0x20,0x00,0x10,0x10,0xa8,0x88,0xf0,0x80,0x88,0xf0,0xf0,0x80,0xf8,0x20,0x10,0xc0,0x80,0xa8,
        0xa8,0x88,0x88,0x88,0x88,0x70,0x20,0x88,0x50,0x88,0x20,0x50,0x20,0x40,0x20,0x10,0x00,0x00,0x00,0x08,
        0x88,0x88,0x88,0x88,0x20,0x88,0x88,0x20,0x08,0x50,0x20,0xa8,0x88,0x88,0x88,0x88,0xc0,0x80,0x20,0x88,
        0x88,0x88,0x50,0x88,0x10,0x40,0x20,0x08,0x00,0xd8,0x20,0x00,0x50,0x70,0x20,0x68,0x00,0x40,0x10,0xf8,
        0xf8,0x00,0xf8,0x00,0x20,0xc8,0x20,0x10,0x08,0x88,0x08,0x88,0x10,0x88,0x78,0x00,0x00,0x40,0x00,0x08,
        0x20,0xa8,0xf8,0x88,0x80,0x88,0x80,0x80,0xb8,0x88,0x20,0x10,0xc0,0x80,0x88,0x98,0x88,0xf0,0x88,0xf0,
        0x08,0x20,0x88,0x50,0xa8,0x20,0x20,0x40,0x40,0x10,0x10,0x00,0x00,0x00,0x78,0x88,0x80,0x88,0xf8,0x20,
        0x88,0x88,0x20,0x08,0x60,0x20,0xa8,0x88,0x88,0x88,0x88,0x80,0x70,0x20,0x88,0x50,0xa8,0x20,0x88,0x20,
        0x20,0x20,0x10,0x00,0xf0,0x00,0x00,0xf8,0x28,0x28,0x90,0x00,0x40,0x10,0x20,0x20,0x00,0x00,0x00,0x20,
        0x88,0x20,0x20,0x08,0xf8,0x08,0x88,0x20,0x88,0x08,0x00,0x00,0x20,0xf8,0x10,0x00,0x98,0x88,0x88,0x80,
        0x88,0x80,0x80,0x88,0x88,0x20,0x90,0xa0,0x80,0x88,0x88,0x88,0x80,0x88,0xa0,0x08,0x20,0x88,0x50,0xa8,
        0x50,0x20,0x80,0x40,0x10,0x10,0x00,0x00,0x00,0x88,0x88,0x80,0x88,0x80,0x20,0x88,0x88,0x20,0x08,0x60,
        0x20,0xa8,0x88,0x88,0x88,0x88,0x80,0x08,0x20,0x88,0x50,0xa8,0x20,0x88,0x40,0x20,0x20,0x10,0x00,0x70,
        0x20,0x00,0x50,0xa8,0x54,0x90,0x00,0x20,0x20,0x50,0x20,0x20,0x00,0x20,0x40,0x88,0x20,0x40,0x88,0x08,
        0x88,0x88,0x20,0x88,0x08,0x20,0x20,0x10,0x00,0x20,0x20,0x80,0x88,0x88,0x88,0x90,0x80,0x80,0x88,0x88,
        0x20,0x90,0x90,0x80,0x88,0x88,0x88,0x80,0xa8,0x90,0x88,0x20,0x88,0x20,0xd8,0x88,0x20,0x80,0x40,0x08,
        0x10,0x00,0x00,0x00,0x88,0x88,0x88,0x88,0x80,0x20,0x88,0x88,0x20,0x08,0x50,0x20,0xa8,0x88,0x88,0x88,
        0x88,0x80,0x08,0x20,0x88,0x20,0xa8,0x50,0x88,0x80,0x20,0x20,0x10,0x00,0x60,0x20,0x00,0x50,0x70,0x48,
        0x68,0x00,0x10,0x40,0x00,0x00,0x20,0x00,0x20,0x40,0x70,0x70,0xf8,0x70,0x08,0x70,0x70,0x20,0x70,0x70,
        0x20,0x20,0x08,0x00,0x40,0x20,0x78,0x88,0xf0,0x70,0xe0,0xf8,0x80,0x70,0x88,0x70,0x60,0x88,0xf8,0x88,
        0x88,0x70,0x80,0x70,0x88,0x70,0x20,0x70,0x20,0x88,0x88,0x20,0xf8,0x70,0x08,0x70,0x00,0x00,0x00,0x78,
        0xf0,0x70,0x78,0x78,0x20,0x78,0x88,0x70,0x08,0x48,0x70,0xa8,0x88,0x70,0xf0,0x78,0x80,0xf0,0x18,0x78,
        0x20,0x70,0x88,0x78,0xf8,0x18,0x20,0x60,0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x08,0x00,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x30,0x00,
        0x00,0x00,0x00,0x00,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,
    };

    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    StrRef password("The quick brown fox jumps over the lazy dog");
    sanityCheck(testData, password, 456);
}

TEST(Crypto, Sanity3)
{
     // Prime to avoid matching any block size.
    static const size_t HugeSize = 524287;
    
    uint8_t* testDataRaw = new uint8_t[HugeSize];

    srand(123);
    
    for (size_t i = 0; i < HugeSize; ++i)
    {
        testDataRaw[i] = rand() & 0xff;
    }
    
    DataRef testData(testDataRaw, testDataRaw + HugeSize);
    StrRef password("Another password!123");
    sanityCheck(testData, password, 789);

    delete [] testDataRaw;
}

TEST(Crypto, AesCryptRead)
{
    const uint8_t TestDataRaw[] =
    {
        0x41, 0x45, 0x53, 0x02, 0x00, 0x00, 0x19, 0x43, 0x52, 0x45, 0x41, 0x54,
        0x45, 0x44, 0x5f, 0x42, 0x59, 0x00, 0x70, 0x79, 0x41, 0x65, 0x73, 0x43,
        0x72, 0x79, 0x70, 0x74, 0x20, 0x30, 0x2e, 0x34, 0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xfd, 0xcc, 0x35,
        0x7a, 0xae, 0x49, 0xfc, 0x14, 0x4c, 0xa7, 0xa3, 0x30, 0x22, 0x25, 0x1d,
        0x02, 0xb7, 0x2b, 0x45, 0xc2, 0x57, 0xe1, 0x4a, 0x28, 0xb3, 0x7e, 0xe5,
        0xf1, 0xa1, 0xa9, 0xe6, 0xf0, 0xc8, 0xdc, 0x3a, 0x45, 0x76, 0x38, 0x6b,
        0x05, 0x5a, 0x77, 0x15, 0x43, 0x37, 0x13, 0x08, 0x62, 0x33, 0x39, 0xd5,
        0x38, 0x7f, 0x66, 0xe6, 0x0f, 0xb8, 0x6f, 0x19, 0xf7, 0xe0, 0x39, 0x94,
        0x5f, 0x64, 0x37, 0xfc, 0x40, 0x4a, 0x5e, 0x5e, 0x0c, 0x0d, 0xfd, 0xd8,
        0xbd, 0x61, 0x47, 0x11, 0xea, 0x3f, 0x30, 0x01, 0x60, 0xda, 0x5e, 0x8c,
        0xf3, 0x10, 0xd5, 0xd7, 0x8a, 0x96, 0x48, 0x00, 0xef, 0xb8, 0x27, 0x3b,
        0xfa, 0x25, 0x2e, 0x6e, 0x2d, 0x10, 0x51, 0x86, 0xf3, 0x23, 0x79, 0xae,
        0x05, 0xbc, 0x52, 0x6f, 0x18, 0x2c, 0x77, 0x31, 0xfe, 0xf3, 0x1b, 0x12,
        0xe3, 0xca, 0x6e, 0xcd, 0x34, 0x8f, 0xcb, 0x5c, 0xed, 0xdf, 0xdc, 0x16,
        0x19, 0xdc, 0x06, 0x52, 0xda, 0xa0, 0x6c, 0xa4, 0x37
    };

    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    DataRefInStream encryptedIn(testData);

    CryptoInStream cryptIn(encryptedIn, "test");

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kReading);

    std::array<uint8_t, 1024> data;
    ArrayOutStream dataOut(data);

    auto dataSize(cryptIn.read(dataOut, 1024));

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kValidated);

    const uint8_t ExpectedDataRaw[] =
    {
        'T', 'e', 's', 't', '\n'
    };

    ASSERT_EQ(DataRef(data.begin(), data.begin() + dataSize),
              DataRef(ExpectedDataRaw, ExpectedDataRaw + sizeof(ExpectedDataRaw)));
}

TEST(Crypto, AesCryptReadSequential)
{
    const uint8_t TestDataRaw[] =
    {
        0x41, 0x45, 0x53, 0x02, 0x00, 0x00, 0x19, 0x43, 0x52, 0x45, 0x41, 0x54,
        0x45, 0x44, 0x5f, 0x42, 0x59, 0x00, 0x70, 0x79, 0x41, 0x65, 0x73, 0x43,
        0x72, 0x79, 0x70, 0x74, 0x20, 0x30, 0x2e, 0x34, 0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xfd, 0xcc, 0x35,
        0x7a, 0xae, 0x49, 0xfc, 0x14, 0x4c, 0xa7, 0xa3, 0x30, 0x22, 0x25, 0x1d,
        0x02, 0xb7, 0x2b, 0x45, 0xc2, 0x57, 0xe1, 0x4a, 0x28, 0xb3, 0x7e, 0xe5,
        0xf1, 0xa1, 0xa9, 0xe6, 0xf0, 0xc8, 0xdc, 0x3a, 0x45, 0x76, 0x38, 0x6b,
        0x05, 0x5a, 0x77, 0x15, 0x43, 0x37, 0x13, 0x08, 0x62, 0x33, 0x39, 0xd5,
        0x38, 0x7f, 0x66, 0xe6, 0x0f, 0xb8, 0x6f, 0x19, 0xf7, 0xe0, 0x39, 0x94,
        0x5f, 0x64, 0x37, 0xfc, 0x40, 0x4a, 0x5e, 0x5e, 0x0c, 0x0d, 0xfd, 0xd8,
        0xbd, 0x61, 0x47, 0x11, 0xea, 0x3f, 0x30, 0x01, 0x60, 0xda, 0x5e, 0x8c,
        0xf3, 0x10, 0xd5, 0xd7, 0x8a, 0x96, 0x48, 0x00, 0xef, 0xb8, 0x27, 0x3b,
        0xfa, 0x25, 0x2e, 0x6e, 0x2d, 0x10, 0x51, 0x86, 0xf3, 0x23, 0x79, 0xae,
        0x05, 0xbc, 0x52, 0x6f, 0x18, 0x2c, 0x77, 0x31, 0xfe, 0xf3, 0x1b, 0x12,
        0xe3, 0xca, 0x6e, 0xcd, 0x34, 0x8f, 0xcb, 0x5c, 0xed, 0xdf, 0xdc, 0x16,
        0x19, 0xdc, 0x06, 0x52, 0xda, 0xa0, 0x6c, 0xa4, 0x37
    };

    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    DataRefInStream encryptedIn(testData);

    CryptoInStream cryptIn(encryptedIn, "test");

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kReading);

    std::array<uint8_t, 1> buffer;
    ArrayOutStream         bufferOut(buffer);

    ASSERT_EQ(cryptIn.read(bufferOut, 1), 1);
    ASSERT_EQ(buffer[0], 'T');
    bufferOut.reset();

    ASSERT_EQ(cryptIn.read(bufferOut, 1), 1);
    ASSERT_EQ(buffer[0], 'e');
    bufferOut.reset();

    ASSERT_EQ(cryptIn.read(bufferOut, 1), 1);
    ASSERT_EQ(buffer[0], 's');
    bufferOut.reset();

    ASSERT_EQ(cryptIn.read(bufferOut, 1), 1);
    ASSERT_EQ(buffer[0], 't');
    bufferOut.reset();

    ASSERT_EQ(cryptIn.read(bufferOut, 1), 1);
    ASSERT_EQ(buffer[0], '\n');
    bufferOut.reset();

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kValidated);
}

TEST(Crypto, AesCryptTruncated)
{
    const uint8_t TestDataRaw[] =
    {
        0x41, 0x45, 0x53, 0x02, 0x00, 0x00, 0x19, 0x43, 0x52, 0x45, 0x41, 0x54,
        0x45, 0x44, 0x5f, 0x42, 0x59, 0x00, 0x70, 0x79, 0x41, 0x65, 0x73, 0x43,
        0x72, 0x79, 0x70, 0x74, 0x20, 0x30, 0x2e, 0x34, 0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xfd, 0xcc, 0x35,
        0x7a, 0xae, 0x49, 0xfc, 0x14, 0x4c, 0xa7, 0xa3, 0x30, 0x22, 0x25, 0x1d,
        0x02, 0xb7, 0x2b, 0x45, 0xc2, 0x57, 0xe1, 0x4a, 0x28, 0xb3, 0x7e, 0xe5,
        0xf1, 0xa1, 0xa9, 0xe6, 0xf0, 0xc8, 0xdc, 0x3a, 0x45, 0x76, 0x38, 0x6b,
        0x05, 0x5a, 0x77, 0x15, 0x43, 0x37, 0x13, 0x08, 0x62, 0x33, 0x39, 0xd5,
        0x38, 0x7f, 0x66, 0xe6, 0x0f, 0xb8, 0x6f, 0x19, 0xf7, 0xe0, 0x39, 0x94,
        0x5f, 0x64, 0x37, 0xfc, 0x40, 0x4a, 0x5e, 0x5e, 0x0c, 0x0d, 0xfd, 0xd8,
        0xbd, 0x61, 0x47, 0x11, 0xea, 0x3f, 0x30, 0x01, 0x60, 0xda, 0x5e, 0x8c,
        0xf3, 0x10, 0xd5, 0xd7, 0x8a, 0x96, 0x48, 0x00, 0xef, 0xb8, 0x27, 0x3b,
        0xfa, 0x25, 0x2e, 0x6e, 0x2d, 0x10, 0x51, 0x86, 0xf3, 0x23, 0x79, 0xae,
        0x05, 0xbc, 0x52, 0x6f, 0x18, 0x2c, 0x77, 0x31, 0xfe, 0xf3, 0x1b, 0x12,
        0xe3, 0xca, 0x6e, 0xcd, 0x34, 0x8f, 0xcb, 0x5c, 0xed, 0xdf, 0xdc, 0x16,
        0x19, 0xdc, 0x06, 0x52, 0xda, 0xa0, 0x6c, 0xa4
    };

    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    DataRefInStream encryptedIn(testData);

    CryptoInStream cryptIn(encryptedIn, "test");

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kReading);
    
    std::array<uint8_t, 1024> data;
    ArrayOutStream dataOut(data);

    cryptIn.read(dataOut, 1024);

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kTruncated);
}

TEST(Crypto, AesCryptBadDataHmac)
{
    const uint8_t TestDataRaw[] =
    {
        0x41, 0x45, 0x53, 0x02, 0x00, 0x00, 0x19, 0x43, 0x52, 0x45, 0x41, 0x54,
        0x45, 0x44, 0x5f, 0x42, 0x59, 0x00, 0x70, 0x79, 0x41, 0x65, 0x73, 0x43,
        0x72, 0x79, 0x70, 0x74, 0x20, 0x30, 0x2e, 0x34, 0x00, 0x80, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xfd, 0xcc, 0x35,
        0x7a, 0xae, 0x49, 0xfc, 0x14, 0x4c, 0xa7, 0xa3, 0x30, 0x22, 0x25, 0x1d,
        0x02, 0xb7, 0x2b, 0x45, 0xc2, 0x57, 0xe1, 0x4a, 0x28, 0xb3, 0x7e, 0xe5,
        0xf1, 0xa1, 0xa9, 0xe6, 0xf0, 0xc8, 0xdc, 0x3a, 0x45, 0x76, 0x38, 0x6b,
        0x05, 0x5a, 0x77, 0x15, 0x43, 0x37, 0x13, 0x08, 0x62, 0x33, 0x39, 0xd5,
        0x38, 0x7f, 0x66, 0xe6, 0x0f, 0xb8, 0x6f, 0x19, 0xf7, 0xe0, 0x39, 0x94,
        0x5f, 0x64, 0x37, 0xfc, 0x40, 0x4a, 0x5e, 0x5e, 0x0c, 0x0d, 0xfd, 0xd8,
        0xbd, 0x61, 0x47, 0x11, 0xea, 0x3f, 0x30, 0x01, 0x60, 0xda, 0x5e, 0x8c,
        0xf3, 0x10, 0xd5, 0xd7, 0x8a, 0x96, 0x48, 0x00, 0xef, 0xb8, 0x27, 0x3b,
        0xfa, 0x25, 0x2e, 0x6e, 0x2d, 0x10, 0x51, 0x86, 0xf3, 0x23, 0x79, 0xae,
        0x05, 0xbc, 0x52, 0x6f, 0x18, 0x2c, 0x77, 0x31, 0xfe, 0xf3, 0x1b, 0x12,
        0xe3, 0xca, 0x6e, 0xcd, 0x34, 0x8f, 0xcb, 0x5c, 0xed, 0xdf, 0xdc, 0x16,
        0x19, 0xdc, 0x06, 0x52, 0xda, 0xa0, 0x6c, 0xa5, 0x37
    };

    DataRef testData(TestDataRaw, TestDataRaw + sizeof(TestDataRaw));
    DataRefInStream encryptedIn(testData);

    CryptoInStream cryptIn(encryptedIn, "test");

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kReading);
    
    std::array<uint8_t, 1024> data;
    ArrayOutStream dataOut(data);

    cryptIn.read(dataOut, 1024);

    ASSERT_EQ(cryptIn.state(), CryptoInStream::State::kBadDataHmac);
}
